******
* URefs, RVals and move semantics
******

Scott Meyers
http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers
  http://habrahabr.ru/post/157961/

Kondratskiy - Moves Demystified:
http://kholdstare.github.io/technical/2013/11/23/moves-demystified.html
http://www.reddit.com/r/cpp/comments/1r9t1z/moves_demystified_c11_article/

Becker:
http://thbecker.net/articles/rvalue_references/section_01.html

Stroustroup - A Brief Introduction to Rvalue References:
http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2006/n2027.html
http://www.artima.com/cppsource/rvalue.html

Semenov - Move Semantics and Perfect Forwarding in C++11
http://www.codeproject.com/Articles/397492/Move-Semantics-and-Perfect-Forwarding-in-Cplusplus

Koenig - Short Articles about move:
http://www.drdobbs.com/cpp/how-the-c-compiler-decides-to-move-objec/240158035
http://www.drdobbs.com/cpp/some-optimizations-are-more-important-th/240159684
http://www.drdobbs.com/cpp/an-important-move-optimization-is-nearly/240160031

Abrahams - Want Speed - Pass by Value:
http://cpp-next.com/archive/2009/08/want-speed-pass-by-value/
http://cpp-next.com/archive/2009/09/making-your-next-move/
http://cpp-next.com/archive/2009/09/your-next-assignment/
http://cpp-next.com/archive/2009/10/exceptionally-moving/
http://cpp-next.com/archive/2009/12/onward-forward/

Parent - Value Semantics and Concept Based Polymorphism:
http://2012.cppnow.org/session/value-semantics-and-concepts-based-polymorphism/
http://isocpp.org/blog/2012/12/value-semantics-and-concepts-based-polymorphism-sean-parent

Marco - Capture by Move (including lambdas):
http://marcoarena.wordpress.com/2012/11/01/learn-how-to-capture-by-move/
http://jrb-programming.blogspot.com/2012/11/another-alternative-to-lambda-move.html
http://www.codeproject.com/Articles/515655/Anotherplusalternativeplustopluslambdaplusmoveplus

Only in russian:
http://www.rsdn.ru/article/cpp/Cpp11NewStd.xml


From Meyers:
std::move    is an unconditional cast to r-val
  the better name for std::move will be rvalue_cast
  std::move turns its arg to rval even if it isn't, and achieves that by "hiding the name"

std::forward ...     conditional ...
  casts param to rval iff rval was passed in

// conceptual impl at namespace std

template<typename T>
T &&forward(T &&param)
{
    if (is_lvalue_reference<T>::value)
      return param
    else
      return move(param); // cast to rval
}

Universal ref - can become either lval or rval

decltype(auto) - for return type

Ex 1:

class string {
public:
  ...
  string &operator=(const string &rhs); // copy assignment
  string &operator=(string &&rhs);      // move assignment
  ...
};

void processAndAdd(const string s)
{
  ...
  sds.name = std::move(s); // copies s! since s is declared as const
  ...
}

Ex 2:

void process(Widget &lvalParam);
void process(Widget &&rvalParam);

template<typename T>
void logAndProcess(T &&param)
{
  ...
  process(std::forward<T>(param));
}

Widget w;
logAndProcess(w);            // call with lval
logAndProcess(std::move(w)); // call with rval


From Lavavej:
don't return by &&
don't return by const &
(NOTE: RVO, NRVO optimizations do the job)


From ... Becker:

Derived(Derived &&rhs)
: Base (std::move(rhs))  // !!! very important to cast to rval here, maybe using std::forward
{
  // other stuff
}

RVO (return value optimization)

X foo()
{
  X x;
  // ...
  return x;  // !!! don't need to call std::move since compiler does RVO and would construct X object directly at the location of foo's return value
}

Ex 3. We use URef when there is a type-deduction, if there is no - we just about RRef

void std::vector<Widget>::push_back(Widget &&x);  // no type-deduction needed, so - RRef

template<class ...Args>
void std::vector<Widget>::emplace_back(Args &&... args);  // type-deduction, so - URef

Ex 4.

Reference collapsing is used for:
- template arg deduction
- auto-vars
- decltypes

Ex 5.

template<class... Args>
void emplace_back(Args &&... args);

Appends a new element to the end of the container. The element is constructed in-place, i.e. no copy or move operations are performed.

