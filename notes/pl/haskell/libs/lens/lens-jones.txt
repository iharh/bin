17:17

newtype Identity a = Identity { runIdentity :: a } 

instance Functor Identity where
  fmap f (Identity x) = Identity (f x)


type Lens' s a = forall f. Functor f => (a -> f a) -> s -> f s

-- set

We need to go from (f s) to (s). Let's use Identity/runIdentity for that

set :: forall s a. Lens' s a -> (a -> s -> s)

set ln x s = runIdentity (ln set_fld s)
  where
    set_fld :: a -> Identity a
    set_fld _ = Identity x  -- discard current value, return new value 'x'

-- Edward would write it

const :: a -> b -> a
const x _ = x

set :: forall s a. Lens' s a -> (a -> s -> s)
set ln x = runIdentity . ln (Identity . const x)

-- over

Let's generalize what we've done with const - approach to arbitrary function f

set  :: forall s a. Lens' s a ->  a       -> s -> s
over :: forall s a. Lens' s a -> (a -> a) -> s -> s

set  ln x = runIdentity . ln (Identity . const x)
over ln f = runIdentity . ln (Identity . f      )

over :: forall s a. Lens' s a -> (a -> a) -> s -> s
over ln f = runIdentity . ln (Identity . f)

-- view

We need to go from (f s) to (a) ???

set  :: forall s a. Lens' s a ->  a       -> s -> s
view :: forall s a. Lens' s a             -> s -> s

view :: forall s a. Lens' s a -> s -> s
view = ???

We need to go from (f s) to (a)... Let's pack (a) inside the (f).

newtype Const v a = Const v

getConst :: Const v a -> v
getConst (Const x) = a

instance Functor (Const v) where
  fmap f (Const x) = Const x  -- (Const v) functor ignores its argument a


view :: forall s a. Lens' s a -> s -> s
view ln s = getConst (ln Const s)  -- here we using  Const :: a -> Const a a

-- Edward would write it

view :: forall s a. Lens' s a -> s -> s
view ln = getConst . ln Const

-- Example: Lens construction

type Lens' s a = forall f. Functor f => (a -> f a) -> s -> f s

data Person = P { _name :: String, _salary :: Int }

name :: Lens' Person String
-- name :: Functor f => (String -> f String) -> Person -> f Person

name elt_fn (P n s) = fmap (\n' -> P n' s) (elt_fn n)

1. elt_fn :: String -> f String  -- :: a -> fa

2. fmap :: Functor f => (a -> b) -> f a -> f b

3. (\n' -> P n' s) :: String -> Person  -- This function is like a data structure with a hole in it

4. (elt_fn n) :: f String

name elt_fn (P n s) = (\n' -> P n' s) <$> (elt_fn n)  -- (<$>) = fmap in Data.Functor

-- ... Lens usage

> let fred = P { _name = "Fred", _salary = 100 }

> view name
"Fred"

> set name "Bill" fred
P { _name = "Bill", _salary = 100 }


-- How does things work ???

view name (P { _name = "Fred", _salary = 100 } )
  -- inline view
= getConst (name Const (P { _name = "Fred", _salary = 100 } ))
  -- inline name
= getConst (fmap (\n' -> P n' 100) (Const "Fred"))
  -- fmap f (Const x) = Const x
= getConst (Const "Fred")
  -- getConst (Const x) = x
= "Fred"

Note: The newtype has no runtime cost
      It just tells the "Functor f => " which functor dictionary to pass to 'ln'.

-- Making lenses easily

import Control.Lens.TH

$(makeLenses ''Person)  -- expands to a lens for 'name' and one for 'salary'.


-- Lenses composition

Note: is just an ordinary functional composition

data Person = P { _name :: String, _addr :: Address, _salary :: Int }

data Address = A { _road :: String, _city :: String, _postcode :: String }


$(makeLenses ''Person)
$(makeLenses ''Address)

setPostcode :: String -> Person -> Person
setPostcode pc p = set (addr . postcode) pc s

-- Line noise (infix operators)

(.~) = set
f $ x = f x

setPostcode = addr.postcode .~ pc $ p

-- What are the other usages of (Functor f) other than Const and Identity ???

-- Application (Virtual fields) --

data Temp = T { _farenheit :: Float }

$(makeLenses ''Temp)
-- farenheit :: Lens Temp Float

centigrade :: Lens Temp Float
centigrade centi_fn (T faren)
  = (\centi' -> T (cToF centi'))
    <$> (centi_fn (fToC faren))

cToF :: Float -> Float  -- Centigrade to Farenheit
fToC :: Float -> Float  -- Farenheit to Centigrade

-- the 'centigrade' field isn't "really there", 
   but the centigrade lens is fully first class


-- Application (invariants)

data Time = T { _hours :: Int, _mins :: Int }

- We want adding to mins to affect hours

> let now = T { _hours = 3, _mins = 58 }
> over mins (+ 4) now
T { _hours = 4, _mins = 2 }

mins :: Lens Time Int
mins min_fn (T h m)
  = wrap <$> (min_fn m)  -- (min_fn m) :: f Int
  where
    wrap :: Int -> Time
    wrap m' | m' >= 60  = T (h + 1) (m' - 60)
            | m'  < 0   = T (h - 1) (m' + 60)
	    | otherwise = T h m'


-- Application (Non-record data structures from Control.Lens.At)

at :: Ord k => k -> Lens' (Map k v) (Maybe v)

- Focus is the value for a key
- Can be Nothing (key not mapped) or (Just v)

at k mb_fn m
  = wrap <$> (mb_fn mv)
  where
    mv = Map.lookup k m

    wrap :: Maybe v -> Map k v
    wrap (Just v') = Map.insert k v' m
    wrap Nothing   = case mv of
                       Nothing -> m
		       Just _  -> Map.delete k m

- at is a parameterized (by key k) lens


-- Application (Bit fields from Data.Bits.Lens)

bitAt :: Int -> Lens' Int Bool

> view (bitAt 1) 3
True
> view (bitAt 1) 2
True
> view (bitAt 1) 5
False

bitAt :: Bits b => Int -> Lens' b Bool


-- Application (Fumbling in deep data structures -- Web-scraper from hexpat-lens package)

p ^.. _HTML' . to allNodes
             . traverse . named "a"
	     . traverse . ix "href"
	     . filtered isLocal
	     . to trimSpaces


- The second great Edward's idea about generalization

type Lens' s a = forall f. Functor f => (a -> f a) -> (s -> f s)

- We have seen that we can instantiate 'f' in various ways
- But what if we changed "Functor" ?

type Traversal' s a = forall f. Applicative f => (a -> f a) -> (s -> f s)

-- A Traversal is a lens with multiple foci (focuses)
-- Traversal' s a   --- can point to multiple places withing a data structure.

- What on earth is Applicative ?

class Functor f => Applicative f where
  pure  :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b

-- A bit like Monad but weaker

class Monad m where
  return :: a -> m a
  (>>=)  :: m a -> (a -> m b) -> m b

-- Every Monad is an Applicative

  pure = return
  mf <*> mx = do { f <- mf; x <- mx; return (f x) }

- But not vice versa
