Git manages tags/refs, pointing to the commit-objects, organized in a DAG-graph of trees, consisting of the smaller-trees and file-blobs objects (sometimes moved to a packs)

Presentations
https://speakerdeck.com/matthewmccullough/git-graphs-hashes-and-compression-oh-my-1 (http://youtu.be/ig5E8CcdM9g)
http://www.slideshare.net/chacon/git-101-presentation
http://www.slideshare.net/chacon/getting-git
  Slide 78 - Object database format

http://www.infoq.com/presentations/A-Tale-of-Three-Trees
  working-dir, index/staging, repo/head


interesting:

Types of git objects:
  blob (every file under source control is written into a blob)
  tree
  commit
  tag


Env vars:
GIT_DIR
  path to the .git dir



REBASE:

interactive:
git rebase -i <branch/commit/tag> 

auto:
git config --global branch.autosetuprebase always
git config branch.7.x.rebase true

protection

(to disable  git push --force):
git config --system receive.denyNonFastForwards true


alias deflate="perl -MCompress::ZLib -e 'undef $/; print uncompress(<>)'"

git cat-file -t <hash>  get type
             -p <hash>  print


git fsck --full --strict
	to check the repo-validity

git rev-parse <human-hash>
	[pick out and massage parameters]
	to get a sys-id (long) from a human-readable (short) form

git rev-parse 'master^{tree}'
	.. commit tree

git describe --tags master
git describe --tags HEAD
	describe (find nearest tag) non-annotated tag


treeish
	tree hashes
commitish
	commit hashes

- full SHA1
- partial SHA1
- branch, remote or tag name
  (adding a date spec like @{yesterday} or @{1 mongh ago}, @{5} 5 prior values...)
- carrot parents (history)
  <hash>^
    one commit back (parent)
  <hash>^2
    second parent (in case if <hash> is a merge commit)
  <hash>^^
    two ...
  <hash>~5
    five ...
- tilde specs
  master~2
    2nd generation grandparent of master (grandparent)
- tree spec
  master^{tree}
    tree that 'master' points to (tree object, usefull for running ls-tree)
- blob spec
  master:/path/to/file
    if you need a certain file of the 'master' commit
- ranges
  <hash1>..<hash2>
    between ... note - branches can also be used here.
  <hash1>..
    everything since a commit


git show <hash>
	show a WHOLE commit (or something else) of the hash
git show <hash>:FILE
	.. just a specific FILE

	REF:FILE
		blob spec
	:0:FILE
		index (stage area)
	:1:FILE
		common ancestor, find by a merge base
	:2:FILE
		target (on a current branch that you're on)
	:3:FILE
		the one you're bringing in (with merge)


BRANCHES:
git branch -v
	get branches with hashes.
git ls-remote -v
	.. remote
    show-branch


Remotes:
git remote add <nick> git://...repo.git
git fetch <nick>
git push <nick> master[or other branch name here]
  now git remote should list public
  git remote show public ...

pull = fetch + merge



Diff/patches
git diff
    apply
    format-patch -o patches origin
                 origin/master --stdout > story.patch
    send-patch --to list@email.com patches
    am < story.patch

git diff --cached
  look what will be included into commit  


git clone:
http://git-scm.com/docs/git-clone

git clone -n <remote-repo>
-n is --no-checkout

git clone -l --no-hardlinks <local-repo-path>
-l is --local


MIRRORING:

git clone --mirror ...

:: HEAD - currently checked out branch
git remote -v update --prune
:: git fetch --prune -v --multiple --all
:: git fetch --append --prune -v origin

git gc


LOG:
git log --no-merges

git log -1 --pretty=format:%H
for /f "delims=" %%a in ('git log -1 "--pretty=format:%%H"') do echo %%a

git log -p
  commit history with changes (diff)

  --stat   ...
  --graph  ...


ARCHIVING:

git archive -o latest.zip HEAD

RECOVERING
http://blog.ctp.com/2013/11/21/git-recovering-from-mistakes/

UNSTAGING:

git rm --cached database.yml
  remove from staging, leaving it at work-dir (to be added to .gitignore later)


git reset HEAD file
  rollback the indexation (seems like the same as above-one command)


STATUS

git status -s
  less verbose status

